\chapter{Theoretical Framework for Code Refactoring}

\section{Background}

% ---
% Defining Refactoring
% ---


% Intro
Refactoring is a well established concept in software development. 
Especially in complex projects, 
	tasks such as cleaning and restructuring code are regularly occuring and oftentimes necessary. 
When refering to these activities by name, many employees describe them as refactoring. 
Despite of its familiarity, 
	the exact definition of the term \emph{refactoring} is not always self evident.
To avoid refering to the term too loosely, 
	it is therefore important to give a precise definition to reference throughout the paper. 

% Fowler Refactoring Definition
Martin \textcite[p. ~xiv]{fowler2018} managed to formulate a definition that is both short and precise. 
Notably, Fowler is one of the most prominent figure, 
	who has pioneered many concept in the field of refactoring,
	which validates the utilization of his definition.
Fowler defines refactoring the following:
\begin{quote}
\textbf{Refactoring} is the process of changing a software system in a way 
	that does not alter the external behavior of the code yet improves its internal structure.
\end{quote}

% Definition in Own Words
It is therefore an integral part of reactoring to not change the features of the program, 
	while improving the quality of the code.
By proper refactoring, we can thus eleviate the risk associated with changing the codebase,
	while improving the internal structure of the program.

% ---
% Objective: Explain External behavior and Internal Structure
% ---

\myparagraph{Objective}

% Adding Features is attractive
Spending valuable ressources, while not adding new features, 
	might sound unappealing to many managers and even programmers.
\textcite[p.~1]{kim2012} mention the problem of not having an immediate benefit when refactoring, 
	unlike new features or bug fixes.
In addition, the value of improving the internals of the code, is hard to show to a manager, 
	who is not an expert and even harder to present to the client, who is paying for the work.
Through continuous modifications and adaptations to new requirements, the code becomes increasinlgy complex and drifts away from original design. 
As a consequence, 
	a major part of the resources is spent on software maintenance (\cite[p.~1]{mens2003}). 

% Refactoring necessary to avoid maintenance costs
However, having Fowler's Definition in mind, 
	we aim to mitigate time spent on tedious maintenance, 
	by improving the quality attributes of the code and thus its internal structure.
Conversely, by ignoring the internals of the program, 
	there would exist a continuous increase of debt, 
	which would have to be repaid in the future in the form of maintenance costs.
Moreover, by obtaining so called technical debt, 
	future features are more costly to implement and sudden changes are near impossible. 
The concept of technical debt is an important one to fully grasp, 
	which is why it is further explained in a future section of this paper 
(see Section \ref{sec:Business}).
	

% Internal Structure = Improving the Quality Attributes
Refactoring helps to make the code more readable, 
	as well as improving the internal quality attributes of the software (\cite[p.~129]{mens2004}). 
Some refactorings remove code redundancy, 
	some raise the level of abstraction, 
	some enhance the reusability, and so on.
On a higher level, these quality attributes include whether the software is maintainable, modifiable, testable and much more.
The effect of a refactor can to a certain extent be estimated, 
	by the level of improvement in these quality attributes.
Consequently, the transformation of the internal structure 
	is the deciding factor on which sucess is measured.
Ultimatlely, refactoring adds value if at least one quality attribute has significantly improved.

% External Structure = Tests
There is however one caveat when measuring the added value,
	which is that the external behavior is not altered. 
As an example, changing the code base could make the program more modulear, 
	but during the process create bugs that didn't exist before. 
Accordingly, it must be proven that only the internal structure has changed.
This is achieved by writing tests beforehand and then testing the features after the refactor.
Thereby, software tests is a major component when deciding the sucess of a refactor.


% ---
% Criteria: When should we Refactor
% ---
% 3 Key Benefits: Why Should we Refactor
% ---

\myparagraph{Benefits}

% Critical Perspective
There needs to be less justification when it comes to time spent on new features and fixing bugs.
As discussed earlier, it is significantly harder to persuade doing a refactor, 
	as there are fewer immediate benefits.
For that reason, one needs to verify the necessity of a refactor 
	and compare it to the need of other pending tasks.
\textcite[p.~5]{fowler2018} points out that if the code works and doesn't ever need to change, 
	it's fine to leave it alone.
He suggests that as soon as someone needs to understand how that code works, 
	and struggles to follow it, one has to do something about it.
Hence, we can conclude that the potential improvement in quality, doesn't warrant a refactor by itself.

% Small Refactors
It is crucial to state that refactoring should not be considered to be a massive, obscure undertaking.
Even if there is a demand of a huge refactor, the refactorings themselves are minor.
Refactoring is all about applying small behavior-preserving steps and making a big change by stringing together a sequence of these behavior-preserving steps (\cite[p.~45]{fowler2018}). 
For this reason, refactoring as a principle, 
	always plays a key role, 
	as code being easier to understand and cheaper to modify is vital in software development.
Therefore, with a project that is in active development, 
	active monitoring of the code quality and therefore being willing to do continous improvements 
	by means of refactorings is advisable.
However, as one may presume, such activities are done more in the background and differ from fundamental refactorings or even rewrites of the entire code base.

% Big Step
Another question is the scope of how many of these small refactoring steps needs to be applied.





\section{Formalization of Design Patterns}

% Transition: Relationship between Refactoring and Code Smells
Knowing just the importance and applicatons of refactoring does not suffice, 
	as one still needs to understand when to do the refactoring.
\textcite{fowler2018} argues that deciding when to start refactoringâ€”and when to stop 
	is just as important to refactoring as knowing how to operate the mechanics of it.
Particularly, there is no clear cut moment when to refactor, 
	there are only indications that there is trouble that can be solved by a refactoring.
In practice, these indications are known as code or design Smells.
As throughout this work we are not concerned with design decisions of the codebase, 
	we will from now on refer to the indications as code smells.

% What is a Code Smell?
	% TODO: Define Code Smells here %
Refactoring can then can be thought of as the process of getting rid of these code smells. 

% Examples Intro
To better comprehend these code smells it is best to list some of them. 
However, to stay within the scope of this paper, 
	we will limit the examples to the most prominent ones. 
In their work, Fowler and Beck introduced a total of 24 code smells to avoid.
Therefore, the following overview will briefly summarize the top ten code smells according to \textcite{lacerda2020}.

% Table
	% TODO: Need to be in list of figures, right?
\myparagraph{Table 1}
Summary of code smells identified by Fowler and Beck \textcite{fowler2018}

\newcolumntype{b}{X}
\newcolumntype{s}{>{\hsize=.5\hsize}X}
\renewcommand{\arraystretch}{1.7}
\scalebox{0.8}{
\begin{tabularx}{1.2\textwidth}{{sb}}
	Code Smells & Description \\
 \hline
	Duplicated Code & Consists of equal or very similar passages in different fragments of the same code base.  \\
	Large Class & Class that has many responsibilities and therefore contains many variables and methods. \\
	Feature Envy & When a method is more interested in members of other classes than its own,
		is a clear sign that it is in the wrong class \\
	Long Method & Very large method/function and, therefore, difficult to understand, extend and modify.
		It is very likely that this method has too many responsibilities,
		hurting one of the principles of a good OO design \\
	Long Parameter List & Extensive parameter list, which makes it difficult to understand
		and is usually an indication that the method has too many responsibilities. \\
	Data Clumps & Data structures that always appear together,
		and when one of the items is not present, the whole set loses its meaning \\
	Refused Bequest & It indicates that a subclass does not use inherited data or behaviors \\
	Divergent Change & A single class needs to be changed for many reasons.
		This is a clear indication that it is not sufficiently cohesive and must be divided \\
	Shotgun Surgery & Opposite to Divergent Change,
		because when it happens a modification, several different classes have to be changed \\
	Lazy Class & Classes that do not have sufficient responsibilities and therefore should not exist \\
\end{tabularx}
}


\section{The Business Case for Refactoring}
\label{sec:Business}

% \section{Thesis Context}
